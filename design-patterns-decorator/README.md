## 一、简要说明
> 装饰器模式（DecoratorPattern）是一种结构型设计模式，它动态地给一个对象添加一些额外的职责，就增加功能来说，装饰器模式相比生成子类更为灵活。这种模式创建了一个装饰类，用来包装原有的类，并在保持原有类方法签名完整性的基础上，提供了额外的功能。

## 二、关键角色

1. Component（组件接口）：定义一个对象接口，可以给这些对象动态地添加职责。
2. ConcreteComponent（具体组件）：定义了一个具体的对象，也可以给这个对象添加一些职责。
3. Decorator（装饰器接口）：持有一个Component对象的引用，并定义一个与Component接口一致的接口。
4. ConcreteDecorator（具体装饰器）：负责给Component添加具体的职责，也实现了Component接口。


## 三、实现方式

* 装饰器类继承自装饰器接口，并在其内部持有一个Component对象的引用，通过构造函数传入具体组件。
* 扩展功能：装饰器类通过覆盖或扩展Component接口中的方法，可以在调用原有方法的基础上添加新的功能。

## 四、优点

* 灵活性高：装饰器可以在运行时动态地给对象添加职责，不需要修改原有代码。
* 遵循开放封闭原则：对扩展开放，对修改封闭，可以很容易地给系统添加新功能。
* 清晰的职责划分：每个装饰器类负责一项具体职责，使得系统结构更加清晰。

## 五、缺点

* 装饰器使用不当会导致系统复杂：如果过度使用装饰器，可能会导致对象的创建和维护变得复杂。
* 装饰器模式会比简单的继承更加消耗资源：因为每个装饰器都会创建一个新的对象。

## 六、适用场景

* 需要动态地给一个对象添加功能，这些功能可以相互组合。
* 需要为现有功能提供不同变体，但不想使用子类来实现。
* 当不能采用继承来扩展功能，因为类的继承层次已经非常深，或者继承会导致类型体系变得复杂和难以管理。