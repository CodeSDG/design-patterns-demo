## 一、设计原则

在Java中，设计模式是为了提高代码的可维护性、可复用性和可扩展性。常见的设计原则包括：

* **开放封闭原则** (Open/Closed Principle)

>开放封闭原则主张软件实体（如类、模块、方法等）应该对扩展开放，对修改封闭。这意味着您应该能够轻易地向系统中添加新功能，而不必改动现有的、经过验证的代码。要达到这一点，通常需要依赖于抽象（比如接口或抽象类），并通过继承或组合来实现新功能，而不是直接修改原有代码。这样做可以提高软件的可维护性和可扩展性。

* **单一职责原则** (Single Responsibility Principle)

> 单一职责原则主张一个类只负责一个功能，而不是负责多个功能。控制类的粒度大小、将对象解耦、提高其内聚性。

* **里氏替换原则** (Liskov Substitution Principle)

> 里氏替换原则指出，任何使用基类的地方都应该能透明地使用其子类的对象，而不会出现错误或异常行为。换句话说，子类应当能够替换掉它们的基类，并且客户端代码无需知道这一替换。这要求子类必须遵守基类的合同（即方法的预设条件和后置条件），并保持接口的一致性。

* **依赖倒置原则** (Dependency Inversion Principle)

> 依赖倒置原则强调高层模块不应该依赖于低层模块，二者都应该依赖于抽象。同时，抽象不应该依赖于细节，细节应该依赖于抽象。这意味着要依赖接口而非具体实现，通过注入依赖（如使用依赖注入框架）来解耦模块，从而提高系统的灵活性和可测试性。

* **接口隔离原则** (Interface Segregation Principle)

> 接口隔离原则提倡使用多个专门的接口，而不是单一的总接口。每个接口应该专注于一个特定的客户端，客户端不应被迫依赖它不需要的方法。这样做可以减少不必要的耦合，使系统更加灵活和易于维护。

* **迪米特法则** / 最少知识原则 (Law of Demeter / Least Knowledge Principle)

> 迪米特法则建议一个对象应当尽可能少地了解其他对象。具体来说，一个对象应该只与它的直接朋友交流：它自己创建的对象、它所包含的对象、它所直接依赖的对象。这条原则鼓励减少对象之间的耦合，促进松耦合的设计，使得系统更易于理解和维护。

* **合成复用原则** (Composite Reuse Principle)

> 合成复用原则提倡使用组合（对象包含对象）而非继承来实现复用。也就是说，新功能应该通过将对象组合在一起而获得，而不是通过继承来扩展基类。这样做可以降低类之间的耦合度，使得系统更加灵活，也更容易控制对象的行为。

**这些原则共同构成了面向对象设计的核心思想，帮助开发者设计出更灵活、可维护和可扩展的软件系统。**

---

## 二、设计模式分类

Java中常用的设计模式主要包括以下几类，这些模式按照目的和用途被分类为创建型、结构型和行为型模式：

### 创建型模式 (Creational Patterns)

1. **单例模式 (Singleton)**: 确保一个类只有一个实例，并提供一个全局访问点。
2. **工厂方法模式 (Factory Method)**: 定义一个用于创建对象的接口，但让子类决定实例化哪一个类。
3. **抽象工厂模式 (Abstract Factory)**: 提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。
4. **建造者模式 (Builder)**: 将复杂对象的构建与表示分离，使得同样的构建过程可以创建不同的表示。
5. **原型模式 (Prototype)**: 通过克隆已有对象来创建新的对象，以减少创建对象的成本。

### 结构型模式 (Structural Patterns)

1. **适配器模式 (Adapter)**: 将一个类的接口转换成客户希望的另一个接口，使得原本不兼容的接口可以协同工作。
2. **装饰器模式 (Decorator)**: 动态地给一个对象添加一些额外的职责，就增加功能来说，装饰器模式相比生成子类更为灵活。
3. **代理模式 (Proxy)**: 为其他对象提供一个替身或占位符，以控制对这个对象的访问。
4. **桥接模式 (Bridge)**: 将抽象部分与实现部分分离，使它们可以独立变化。
5. **外观模式 (Facade)**: 为一组复杂的子系统提供一个一致的接口，简化高层模块对这些子系统的使用。
6. **组合模式 (Composite)**: 允许你将对象组合成树形结构来表示整体与部分的关系。
7. **享元模式 (Flyweight)**: 运用共享技术有效支持大量细粒度的对象。

### 行为型模式 (Behavioral Patterns)

1. **策略模式 (Strategy)**: 定义一系列算法，将每一个算法封装起来，并使它们可以互相替换。
2. **模板方法模式 (Template Method)**: 定义一个操作中的算法骨架，而将一些步骤延迟到子类中，使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。
3. **观察者模式 (Observer)**: 定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都会得到通知并自动更新。
4. **迭代器模式 (Iterator)**: 提供一种方法顺序访问一个聚合对象中的各个元素，而又不暴露该对象的内部表示。
5. **责任链模式 (Chain of Responsibility)**: 使多个对象都有机会处理请求，从而避免请求的发送者和接收者之间的耦合关系。
6. **命令模式 (Command)**: 将请求封装为一个对象，从而可用不同的请求对客户进行参数化，以及支持可撤销的操作。
7. **状态模式 (State)**: 当一个对象的内在状态改变时允许改变其行为，对象看起来好像修改了它的类。
8. **备忘录模式 (Memento)**: 在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态，以便以后恢复它。
9. **访问者模式 (Visitor)**: 定义一种新的操作作用于某对象结构上，可以在不改变各元素类的前提下定义作用于这些元素的新操作。
10. **中介者模式 (Mediator)**: 用一个中介对象来封装一系列的对象交互，使各对象不需要显式地相互引用。
11. **解释器模式 (Interpreter)**: 给定一种语言，定义它的文法的一种表示，并定义一个解释器，该解释器使用该表示来解释语言中的句子。

这些设计模式在解决特定问题和优化代码结构方面非常有用，是软件开发中的重要工具。

---

## 三、本项目涵盖设计模式说明

本项目的设计模式(暂时)主要包括以下几种常用设计模式：

- [x] **简单工厂模式**
- [x] **工厂方法模式**
- [x] **抽象工厂模式**
- [x] **建造者模式**
- [x] **单例模式**
- [x] **策略模式**
- [x] **责任链模式**
- [x] **模板方法模式**
- [x] **代理模式**
- [x] **观察者模式**
- [x] **装饰器模式**
- [x] **适配器模式**

## 四、本项目常用设计模式模块说明(没有就是没来得及写案例)

| 模块                                                                 | 说明             |
|:-------------------------------------------------------------------|:---------------|
| [design-patterns-dependencies](design-patterns-dependencies)       | 项目版本及依赖管理      |
| [design-patterns-factory](design-patterns-factory)                 | 工厂模式（简单，方法，抽象） |
| [design-patterns-builder](design-patterns-builder)                 | 建造者模式          |
| [design-patterns-singleton](design-patterns-singleton)             | 单例模式           |
| [design-patterns-strategy](design-patterns-strategy)               | 策略模式           |
| [design-patterns-template-method](design-patterns-template-method) | 模板方法模式         |
| [design-patterns-proxy](design-patterns-proxy)                     | 代理模式           |
| [design-patterns-chain](design-patterns-chain)                     | 责任链模式          |
| [design-patterns-observer](design-patterns-observer)               | 观察者模式          |
| [design-patterns-adapter](design-patterns-adapter)                 | 适配器模式          |
| [design-patterns-decorator](design-patterns-decorator)             | 装饰器模式          |
|                                                                    |                |
|                                                                    |                |

